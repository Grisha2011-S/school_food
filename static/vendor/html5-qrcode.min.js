// Minimal shim implementing a subset of the `html5-qrcode` API used by the app.
// Purpose: provide a local fallback if the CDN version is blocked or unavailable.
// It uses navigator.mediaDevices and the native BarcodeDetector when available.
// This is NOT a full implementation of html5-qrcode, but it supports the
// following calls used by the UI:
//  - Html5Qrcode.getCameras() -> Promise<[ { id, label } ]>
//  - new Html5Qrcode(elementId)
//  - instance.start(cameraId, config, successCallback, errorCallback) -> Promise
//  - instance.stop() -> Promise
//  - instance.clear() -> Promise (alias for stop)

(function(){
	if(typeof window === 'undefined') return;
	if(window.Html5Qrcode) return; // don't override if full lib is present

	function mapDevice(d){
		return { id: d.deviceId || d.device || d.id || '', label: d.label || '' };
	}

	class Html5QrcodeShim {
		constructor(elementId){
			this.elementId = elementId;
			this._stream = null;
			this._video = null;
			this._detector = null;
			this._raf = null;
		}

		static getCameras(){
			if(!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices){
				return Promise.resolve([]);
			}
			return navigator.mediaDevices.enumerateDevices()
				.then(devs => devs.filter(d => d.kind === 'videoinput').map(mapDevice));
		}

		start(cameraId, config, successCallback, errorCallback){
			const self = this;
			return new Promise((resolve, reject) => {
				if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
					reject(new Error('MediaDevices.getUserMedia is not available'));
					return;
				}

				const constraints = { video: {} };
				try{
					if(cameraId){
						// sometimes cameraId is a deviceId, sometimes an object; support strings
						constraints.video.deviceId = { exact: String(cameraId) };
					} else {
						constraints.video.facingMode = 'environment';
					}
				}catch(e){}

				navigator.mediaDevices.getUserMedia(constraints).then(stream => {
					self._stream = stream;

					// create or reuse video element
					const container = document.getElementById(self.elementId) || document.body;
					// remove previous children to avoid duplicates
					while(container.firstChild) container.removeChild(container.firstChild);

					const video = document.createElement('video');
					video.style.width = '100%';
					video.style.height = 'auto';
					video.autoplay = true;
					video.muted = true;
					video.playsInline = true;
					video.srcObject = stream;
					self._video = video;
					container.appendChild(video);

					// Setup detector if available
					if(window.BarcodeDetector){
						try{
							self._detector = new BarcodeDetector({ formats: ['qr_code'] });
						}catch(e){
							self._detector = null;
						}
					}

					const scan = () => {
						if(!self._video || self._video.readyState < 2){
							self._raf = requestAnimationFrame(scan);
							return;
						}

						if(self._detector){
							self._detector.detect(self._video).then(results => {
								if(results && results.length){
									try{ successCallback(results[0].rawValue, results[0]); }catch(e){}
								}
								self._raf = requestAnimationFrame(scan);
							}).catch(err => {
								// Ignore per-frame errors
								self._raf = requestAnimationFrame(scan);
							});
						} else {
							// No native detector available â€” we cannot decode without a library.
							// Notify via errorCallback once and continue no-op.
							if(errorCallback) try{ errorCallback(new Error('BarcodeDetector not available')); }catch(e){}
							// resolve to indicate `start` succeeded in playing stream
							resolve();
							return;
						}
					};

					// Start video and scanning loop
					const playPromise = self._video.play();
					if(playPromise && typeof playPromise.then === 'function'){
						playPromise.then(() => {
							self._raf = requestAnimationFrame(scan);
							resolve();
						}).catch(err => {
							// still try scanning loop
							self._raf = requestAnimationFrame(scan);
							resolve();
						});
					} else {
						self._raf = requestAnimationFrame(scan);
						resolve();
					}

				}).catch(err => {
					reject(err);
				});
			});
		}

		stop(){
			const self = this;
			return new Promise(resolve => {
				if(self._raf){
					cancelAnimationFrame(self._raf);
					self._raf = null;
				}
				if(self._stream){
					try{ self._stream.getTracks().forEach(t => t.stop()); }catch(e){}
					self._stream = null;
				}
				if(self._video){
					try{ self._video.pause(); self._video.srcObject = null; }catch(e){}
					const container = document.getElementById(self.elementId) || document.body;
					if(container){ while(container.firstChild) container.removeChild(container.firstChild); }
					self._video = null;
				}
				resolve();
			});
		}

		clear(){
			return this.stop();
		}
	}

	// expose shim
	window.Html5Qrcode = Html5QrcodeShim;
	// also expose a minimal getCameras alias on window in case code calls it directly
	if(!window.html5Qrcode) window.html5Qrcode = { Html5Qrcode: Html5QrcodeShim };
})();
